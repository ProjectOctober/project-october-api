/**
 * generated by Scrooge 3.0.5-SNAPSHOT
 */
package october

import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec}
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import scala.collection.mutable
import scala.collection.{Map, Set}
import com.twitter.util.Future
import com.twitter.conversions.time._
import com.twitter.finagle.{Service => FinagleService}
import com.twitter.finagle.stats.{NullStatsReceiver, StatsReceiver}
import com.twitter.finagle.thrift.ThriftClientRequest
import com.twitter.finagle.SourcedException
import com.twitter.finagle.{Service => FinagleService}
import java.util.Arrays
import org.apache.thrift.transport.{TMemoryBuffer, TMemoryInputTransport, TTransport}


object Recommender {
  trait Iface {
    /** Test for connectivity */
    @throws(classOf[TimeoutException])
    def ping(): String
    /** Request a list of posts that are most appropriate for a user
         * @param user_id, the user that the posts are being requested for
         */
    @throws(classOf[NotFoundException])
    @throws(classOf[EngineException])
    @throws(classOf[TimeoutException])
    def recPosts(userId: Long): PostList
    /** Informs the backend that a new user has been created
         * @param user_id, the user that is being added
         */
    @throws(classOf[EngineException])
    @throws(classOf[TimeoutException])
    def addUser(userId: Long): Boolean
    /** Informs the backedn that a user has submitted a post
         * @param user_id, the user that submitted the post
         * @param post_id, the post the user submitted
         * @param raw_freq, a list of <token, freq> pairs that correspond to the number of times a keyword is in a post.
         */
    @throws(classOf[EngineException])
    @throws(classOf[TimeoutException])
    @throws(classOf[NotFoundException])
    def addPost(userId: Long, postId: Long, rawFreq: Seq[Token] = Seq[Token]()): Boolean
    /** Alert the recommender that a user has actioned a post
         * @param user_id, the user that performed the action
         * @param verb, the action taken (this is from the Action enum)
         * @param post_id, the post that the action is being performed on
         */
    @throws(classOf[NotFoundException])
    def userVPost(userId: Long, verb: Action, postId: Long): Boolean
    /** Alert the recommender that a user has actioned a comment
         * @param user_id, the user that performed the action
         * @param verb, the action taken (this is from the Action enum)
         * @param comment_id, the comment that the action is being performed on
         */
    @throws(classOf[NotFoundException])
    def userVComment(userId: Long, verb: Action, commentId: Long): Boolean
    /** Return the list of top n tokens for a user
         * @param user_id, the user to query for
         * @param limit, the maximum amount of tokens to return 
         */
    @throws(classOf[NotFoundException])
    def userTopTerms(userId: Long, limit: Int): Map[String, Long]
    /** Return a list of documents in sorted order of relevance for a search query
         * @param query, a map of tokens to their weight
         */
    @throws(classOf[EngineException])
    def textSearch(tokens: Seq[String] = Seq[String]()): Map[Long, Double]
  }

  trait FutureIface {
    /** Test for connectivity */
    def ping(): Future[String]
    /** Request a list of posts that are most appropriate for a user
         * @param user_id, the user that the posts are being requested for
         */
    def recPosts(userId: Long): Future[PostList]
    /** Informs the backend that a new user has been created
         * @param user_id, the user that is being added
         */
    def addUser(userId: Long): Future[Boolean]
    /** Informs the backedn that a user has submitted a post
         * @param user_id, the user that submitted the post
         * @param post_id, the post the user submitted
         * @param raw_freq, a list of <token, freq> pairs that correspond to the number of times a keyword is in a post.
         */
    def addPost(userId: Long, postId: Long, rawFreq: Seq[Token] = Seq[Token]()): Future[Boolean]
    /** Alert the recommender that a user has actioned a post
         * @param user_id, the user that performed the action
         * @param verb, the action taken (this is from the Action enum)
         * @param post_id, the post that the action is being performed on
         */
    def userVPost(userId: Long, verb: Action, postId: Long): Future[Boolean]
    /** Alert the recommender that a user has actioned a comment
         * @param user_id, the user that performed the action
         * @param verb, the action taken (this is from the Action enum)
         * @param comment_id, the comment that the action is being performed on
         */
    def userVComment(userId: Long, verb: Action, commentId: Long): Future[Boolean]
    /** Return the list of top n tokens for a user
         * @param user_id, the user to query for
         * @param limit, the maximum amount of tokens to return 
         */
    def userTopTerms(userId: Long, limit: Int): Future[Map[String, Long]]
    /** Return a list of documents in sorted order of relevance for a search query
         * @param query, a map of tokens to their weight
         */
    def textSearch(tokens: Seq[String] = Seq[String]()): Future[Map[Long, Double]]
  }

  
  object PingArgs extends ThriftStructCodec[PingArgs] {
    val Struct = new TStruct("PingArgs")
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: PingArgs) {
    }
  
    def encode(_item: PingArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): PingArgs = decode(_iprot)
  
    def apply(
    ): PingArgs = new Immutable(
    )
  
    def unapply(_item: PingArgs): Boolean = true
  
    object Immutable extends ThriftStructCodec[PingArgs] {
      def encode(_item: PingArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
        )
      }
    }
  
    /**
     * The default read-only implementation of PingArgs.  You typically should not need to
     * directly reference this class; instead, use the PingArgs.apply method to construct
     * new instances.
     */
    class Immutable(
    ) extends PingArgs
  
  }
  
  trait PingArgs extends ThriftStruct
    with Product
    with java.io.Serializable
  {
    import PingArgs._
  
  
  
    override def write(_oprot: TProtocol) {
      PingArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
    ): PingArgs = new Immutable(
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[PingArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "PingArgs"
  }
  
  object PingResult extends ThriftStructCodec[PingResult] {
    val Struct = new TStruct("PingResult")
    val SuccessField = new TField("success", TType.STRING, 0)
    val TeField = new TField("te", TType.STRUCT, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: PingResult) {
    }
  
    def encode(_item: PingResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): PingResult = decode(_iprot)
  
    def apply(
      success: Option[String] = None,
      te: Option[TimeoutException] = None
    ): PingResult = new Immutable(
      success,
      te
    )
  
    def unapply(_item: PingResult): Option[Product2[Option[String], Option[TimeoutException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[PingResult] {
      def encode(_item: PingResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var success: String = null
        var _got_success = false
        var te: TimeoutException = null
        var _got_te = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRING => {
                    success = {
                      _iprot.readString()
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* te */
                _field.`type` match {
                  case TType.STRUCT => {
                    te = {
                      TimeoutException.decode(_iprot)
                    }
                    _got_te = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_te) Some(te) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of PingResult.  You typically should not need to
     * directly reference this class; instead, use the PingResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[String] = None,
      val te: Option[TimeoutException] = None
    ) extends PingResult
  
  }
  
  trait PingResult extends ThriftStruct
    with Product2[Option[String], Option[TimeoutException]]
    with java.io.Serializable
  {
    import PingResult._
  
    def success: Option[String]
    def te: Option[TimeoutException]
  
    def _1 = success
    def _2 = te
  
    override def write(_oprot: TProtocol) {
      PingResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        _oprot.writeString(success_item)
        _oprot.writeFieldEnd()
      }
      if (te.isDefined) {
        val te_item = te.get
        _oprot.writeFieldBegin(TeField)
        te_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[String] = this.success, 
      te: Option[TimeoutException] = this.te
    ): PingResult = new Immutable(
      success, 
      te
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[PingResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => te
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "PingResult"
  }
  
  object RecPostsArgs extends ThriftStructCodec[RecPostsArgs] {
    val Struct = new TStruct("RecPostsArgs")
    val UserIdField = new TField("userId", TType.I64, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: RecPostsArgs) {
    }
  
    def encode(_item: RecPostsArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): RecPostsArgs = decode(_iprot)
  
    def apply(
      userId: Long
    ): RecPostsArgs = new Immutable(
      userId
    )
  
    def unapply(_item: RecPostsArgs): Option[Long] = Some(_item.userId)
  
    object Immutable extends ThriftStructCodec[RecPostsArgs] {
      def encode(_item: RecPostsArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var userId: Long = 0L
        var _got_userId = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* userId */
                _field.`type` match {
                  case TType.I64 => {
                    userId = {
                      _iprot.readI64()
                    }
                    _got_userId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        if (!_got_userId) throw new TProtocolException("Required field 'RecPostsArgs' was not found in serialized data for struct RecPostsArgs")
        new Immutable(
          userId
        )
      }
    }
  
    /**
     * The default read-only implementation of RecPostsArgs.  You typically should not need to
     * directly reference this class; instead, use the RecPostsArgs.apply method to construct
     * new instances.
     */
    class Immutable(
      val userId: Long
    ) extends RecPostsArgs
  
  }
  
  trait RecPostsArgs extends ThriftStruct
    with Product1[Long]
    with java.io.Serializable
  {
    import RecPostsArgs._
  
    def userId: Long
  
    def _1 = userId
  
    override def write(_oprot: TProtocol) {
      RecPostsArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val userId_item = userId
        _oprot.writeFieldBegin(UserIdField)
        _oprot.writeI64(userId_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      userId: Long = this.userId
    ): RecPostsArgs = new Immutable(
      userId
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[RecPostsArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => userId
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "RecPostsArgs"
  }
  
  object RecPostsResult extends ThriftStructCodec[RecPostsResult] {
    val Struct = new TStruct("RecPostsResult")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val NfeField = new TField("nfe", TType.STRUCT, 1)
    val EeField = new TField("ee", TType.STRUCT, 2)
    val TeField = new TField("te", TType.STRUCT, 3)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: RecPostsResult) {
    }
  
    def encode(_item: RecPostsResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): RecPostsResult = decode(_iprot)
  
    def apply(
      success: Option[PostList] = None,
      nfe: Option[NotFoundException] = None,
      ee: Option[EngineException] = None,
      te: Option[TimeoutException] = None
    ): RecPostsResult = new Immutable(
      success,
      nfe,
      ee,
      te
    )
  
    def unapply(_item: RecPostsResult): Option[Product4[Option[PostList], Option[NotFoundException], Option[EngineException], Option[TimeoutException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[RecPostsResult] {
      def encode(_item: RecPostsResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var success: PostList = null
        var _got_success = false
        var nfe: NotFoundException = null
        var _got_nfe = false
        var ee: EngineException = null
        var _got_ee = false
        var te: TimeoutException = null
        var _got_te = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      PostList.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* nfe */
                _field.`type` match {
                  case TType.STRUCT => {
                    nfe = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_nfe = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* ee */
                _field.`type` match {
                  case TType.STRUCT => {
                    ee = {
                      EngineException.decode(_iprot)
                    }
                    _got_ee = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 3 => { /* te */
                _field.`type` match {
                  case TType.STRUCT => {
                    te = {
                      TimeoutException.decode(_iprot)
                    }
                    _got_te = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_nfe) Some(nfe) else None,
          if (_got_ee) Some(ee) else None,
          if (_got_te) Some(te) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of RecPostsResult.  You typically should not need to
     * directly reference this class; instead, use the RecPostsResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[PostList] = None,
      val nfe: Option[NotFoundException] = None,
      val ee: Option[EngineException] = None,
      val te: Option[TimeoutException] = None
    ) extends RecPostsResult
  
  }
  
  trait RecPostsResult extends ThriftStruct
    with Product4[Option[PostList], Option[NotFoundException], Option[EngineException], Option[TimeoutException]]
    with java.io.Serializable
  {
    import RecPostsResult._
  
    def success: Option[PostList]
    def nfe: Option[NotFoundException]
    def ee: Option[EngineException]
    def te: Option[TimeoutException]
  
    def _1 = success
    def _2 = nfe
    def _3 = ee
    def _4 = te
  
    override def write(_oprot: TProtocol) {
      RecPostsResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (nfe.isDefined) {
        val nfe_item = nfe.get
        _oprot.writeFieldBegin(NfeField)
        nfe_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (ee.isDefined) {
        val ee_item = ee.get
        _oprot.writeFieldBegin(EeField)
        ee_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (te.isDefined) {
        val te_item = te.get
        _oprot.writeFieldBegin(TeField)
        te_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[PostList] = this.success, 
      nfe: Option[NotFoundException] = this.nfe, 
      ee: Option[EngineException] = this.ee, 
      te: Option[TimeoutException] = this.te
    ): RecPostsResult = new Immutable(
      success, 
      nfe, 
      ee, 
      te
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[RecPostsResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 4
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => nfe
      case 2 => ee
      case 3 => te
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "RecPostsResult"
  }
  
  object AddUserArgs extends ThriftStructCodec[AddUserArgs] {
    val Struct = new TStruct("AddUserArgs")
    val UserIdField = new TField("userId", TType.I64, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: AddUserArgs) {
    }
  
    def encode(_item: AddUserArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): AddUserArgs = decode(_iprot)
  
    def apply(
      userId: Long
    ): AddUserArgs = new Immutable(
      userId
    )
  
    def unapply(_item: AddUserArgs): Option[Long] = Some(_item.userId)
  
    object Immutable extends ThriftStructCodec[AddUserArgs] {
      def encode(_item: AddUserArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var userId: Long = 0L
        var _got_userId = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* userId */
                _field.`type` match {
                  case TType.I64 => {
                    userId = {
                      _iprot.readI64()
                    }
                    _got_userId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        if (!_got_userId) throw new TProtocolException("Required field 'AddUserArgs' was not found in serialized data for struct AddUserArgs")
        new Immutable(
          userId
        )
      }
    }
  
    /**
     * The default read-only implementation of AddUserArgs.  You typically should not need to
     * directly reference this class; instead, use the AddUserArgs.apply method to construct
     * new instances.
     */
    class Immutable(
      val userId: Long
    ) extends AddUserArgs
  
  }
  
  trait AddUserArgs extends ThriftStruct
    with Product1[Long]
    with java.io.Serializable
  {
    import AddUserArgs._
  
    def userId: Long
  
    def _1 = userId
  
    override def write(_oprot: TProtocol) {
      AddUserArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val userId_item = userId
        _oprot.writeFieldBegin(UserIdField)
        _oprot.writeI64(userId_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      userId: Long = this.userId
    ): AddUserArgs = new Immutable(
      userId
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[AddUserArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => userId
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "AddUserArgs"
  }
  
  object AddUserResult extends ThriftStructCodec[AddUserResult] {
    val Struct = new TStruct("AddUserResult")
    val SuccessField = new TField("success", TType.BOOL, 0)
    val EeField = new TField("ee", TType.STRUCT, 1)
    val TeField = new TField("te", TType.STRUCT, 2)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: AddUserResult) {
    }
  
    def encode(_item: AddUserResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): AddUserResult = decode(_iprot)
  
    def apply(
      success: Option[Boolean] = None,
      ee: Option[EngineException] = None,
      te: Option[TimeoutException] = None
    ): AddUserResult = new Immutable(
      success,
      ee,
      te
    )
  
    def unapply(_item: AddUserResult): Option[Product3[Option[Boolean], Option[EngineException], Option[TimeoutException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[AddUserResult] {
      def encode(_item: AddUserResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var success: Boolean = false
        var _got_success = false
        var ee: EngineException = null
        var _got_ee = false
        var te: TimeoutException = null
        var _got_te = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.BOOL => {
                    success = {
                      _iprot.readBool()
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* ee */
                _field.`type` match {
                  case TType.STRUCT => {
                    ee = {
                      EngineException.decode(_iprot)
                    }
                    _got_ee = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* te */
                _field.`type` match {
                  case TType.STRUCT => {
                    te = {
                      TimeoutException.decode(_iprot)
                    }
                    _got_te = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_ee) Some(ee) else None,
          if (_got_te) Some(te) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of AddUserResult.  You typically should not need to
     * directly reference this class; instead, use the AddUserResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[Boolean] = None,
      val ee: Option[EngineException] = None,
      val te: Option[TimeoutException] = None
    ) extends AddUserResult
  
  }
  
  trait AddUserResult extends ThriftStruct
    with Product3[Option[Boolean], Option[EngineException], Option[TimeoutException]]
    with java.io.Serializable
  {
    import AddUserResult._
  
    def success: Option[Boolean]
    def ee: Option[EngineException]
    def te: Option[TimeoutException]
  
    def _1 = success
    def _2 = ee
    def _3 = te
  
    override def write(_oprot: TProtocol) {
      AddUserResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        _oprot.writeBool(success_item)
        _oprot.writeFieldEnd()
      }
      if (ee.isDefined) {
        val ee_item = ee.get
        _oprot.writeFieldBegin(EeField)
        ee_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (te.isDefined) {
        val te_item = te.get
        _oprot.writeFieldBegin(TeField)
        te_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Boolean] = this.success, 
      ee: Option[EngineException] = this.ee, 
      te: Option[TimeoutException] = this.te
    ): AddUserResult = new Immutable(
      success, 
      ee, 
      te
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[AddUserResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 3
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => ee
      case 2 => te
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "AddUserResult"
  }
  
  object AddPostArgs extends ThriftStructCodec[AddPostArgs] {
    val Struct = new TStruct("AddPostArgs")
    val UserIdField = new TField("userId", TType.I64, 1)
    val PostIdField = new TField("postId", TType.I64, 2)
    val RawFreqField = new TField("rawFreq", TType.LIST, 3)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: AddPostArgs) {
      if (_item.rawFreq == null) throw new TProtocolException("Required field rawFreq cannot be null")
    }
  
    def encode(_item: AddPostArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): AddPostArgs = decode(_iprot)
  
    def apply(
      userId: Long,
      postId: Long,
      rawFreq: Seq[Token] = Seq[Token]()
    ): AddPostArgs = new Immutable(
      userId,
      postId,
      rawFreq
    )
  
    def unapply(_item: AddPostArgs): Option[Product3[Long, Long, Seq[Token]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[AddPostArgs] {
      def encode(_item: AddPostArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var userId: Long = 0L
        var _got_userId = false
        var postId: Long = 0L
        var _got_postId = false
        var rawFreq: Seq[Token] = Seq[Token]()
        var _got_rawFreq = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* userId */
                _field.`type` match {
                  case TType.I64 => {
                    userId = {
                      _iprot.readI64()
                    }
                    _got_userId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* postId */
                _field.`type` match {
                  case TType.I64 => {
                    postId = {
                      _iprot.readI64()
                    }
                    _got_postId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 3 => { /* rawFreq */
                _field.`type` match {
                  case TType.LIST => {
                    rawFreq = {
                      val _list = _iprot.readListBegin()
                      val _rv = new mutable.ArrayBuffer[Token](_list.size)
                      var _i = 0
                      while (_i < _list.size) {
                        _rv += {
                          Token.decode(_iprot)
                        }
                        _i += 1
                      }
                      _iprot.readListEnd()
                      _rv
                    }
                    _got_rawFreq = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        if (!_got_userId) throw new TProtocolException("Required field 'AddPostArgs' was not found in serialized data for struct AddPostArgs")
        if (!_got_postId) throw new TProtocolException("Required field 'AddPostArgs' was not found in serialized data for struct AddPostArgs")
        if (!_got_rawFreq) throw new TProtocolException("Required field 'AddPostArgs' was not found in serialized data for struct AddPostArgs")
        new Immutable(
          userId,
          postId,
          rawFreq
        )
      }
    }
  
    /**
     * The default read-only implementation of AddPostArgs.  You typically should not need to
     * directly reference this class; instead, use the AddPostArgs.apply method to construct
     * new instances.
     */
    class Immutable(
      val userId: Long,
      val postId: Long,
      val rawFreq: Seq[Token] = Seq[Token]()
    ) extends AddPostArgs
  
  }
  
  trait AddPostArgs extends ThriftStruct
    with Product3[Long, Long, Seq[Token]]
    with java.io.Serializable
  {
    import AddPostArgs._
  
    def userId: Long
    def postId: Long
    def rawFreq: Seq[Token]
  
    def _1 = userId
    def _2 = postId
    def _3 = rawFreq
  
    override def write(_oprot: TProtocol) {
      AddPostArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val userId_item = userId
        _oprot.writeFieldBegin(UserIdField)
        _oprot.writeI64(userId_item)
        _oprot.writeFieldEnd()
      }
      if (true) {
        val postId_item = postId
        _oprot.writeFieldBegin(PostIdField)
        _oprot.writeI64(postId_item)
        _oprot.writeFieldEnd()
      }
      if (true) {
        val rawFreq_item = rawFreq
        _oprot.writeFieldBegin(RawFreqField)
        _oprot.writeListBegin(new TList(TType.STRUCT, rawFreq_item.size))
        rawFreq_item.foreach { rawFreq_item_element =>
          rawFreq_item_element.write(_oprot)
        }
        _oprot.writeListEnd()
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      userId: Long = this.userId, 
      postId: Long = this.postId, 
      rawFreq: Seq[Token] = this.rawFreq
    ): AddPostArgs = new Immutable(
      userId, 
      postId, 
      rawFreq
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[AddPostArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 3
  
    override def productElement(n: Int): Any = n match {
      case 0 => userId
      case 1 => postId
      case 2 => rawFreq
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "AddPostArgs"
  }
  
  object AddPostResult extends ThriftStructCodec[AddPostResult] {
    val Struct = new TStruct("AddPostResult")
    val SuccessField = new TField("success", TType.BOOL, 0)
    val EeField = new TField("ee", TType.STRUCT, 1)
    val TeField = new TField("te", TType.STRUCT, 2)
    val NfeField = new TField("nfe", TType.STRUCT, 3)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: AddPostResult) {
    }
  
    def encode(_item: AddPostResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): AddPostResult = decode(_iprot)
  
    def apply(
      success: Option[Boolean] = None,
      ee: Option[EngineException] = None,
      te: Option[TimeoutException] = None,
      nfe: Option[NotFoundException] = None
    ): AddPostResult = new Immutable(
      success,
      ee,
      te,
      nfe
    )
  
    def unapply(_item: AddPostResult): Option[Product4[Option[Boolean], Option[EngineException], Option[TimeoutException], Option[NotFoundException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[AddPostResult] {
      def encode(_item: AddPostResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var success: Boolean = false
        var _got_success = false
        var ee: EngineException = null
        var _got_ee = false
        var te: TimeoutException = null
        var _got_te = false
        var nfe: NotFoundException = null
        var _got_nfe = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.BOOL => {
                    success = {
                      _iprot.readBool()
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* ee */
                _field.`type` match {
                  case TType.STRUCT => {
                    ee = {
                      EngineException.decode(_iprot)
                    }
                    _got_ee = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* te */
                _field.`type` match {
                  case TType.STRUCT => {
                    te = {
                      TimeoutException.decode(_iprot)
                    }
                    _got_te = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 3 => { /* nfe */
                _field.`type` match {
                  case TType.STRUCT => {
                    nfe = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_nfe = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_ee) Some(ee) else None,
          if (_got_te) Some(te) else None,
          if (_got_nfe) Some(nfe) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of AddPostResult.  You typically should not need to
     * directly reference this class; instead, use the AddPostResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[Boolean] = None,
      val ee: Option[EngineException] = None,
      val te: Option[TimeoutException] = None,
      val nfe: Option[NotFoundException] = None
    ) extends AddPostResult
  
  }
  
  trait AddPostResult extends ThriftStruct
    with Product4[Option[Boolean], Option[EngineException], Option[TimeoutException], Option[NotFoundException]]
    with java.io.Serializable
  {
    import AddPostResult._
  
    def success: Option[Boolean]
    def ee: Option[EngineException]
    def te: Option[TimeoutException]
    def nfe: Option[NotFoundException]
  
    def _1 = success
    def _2 = ee
    def _3 = te
    def _4 = nfe
  
    override def write(_oprot: TProtocol) {
      AddPostResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        _oprot.writeBool(success_item)
        _oprot.writeFieldEnd()
      }
      if (ee.isDefined) {
        val ee_item = ee.get
        _oprot.writeFieldBegin(EeField)
        ee_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (te.isDefined) {
        val te_item = te.get
        _oprot.writeFieldBegin(TeField)
        te_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (nfe.isDefined) {
        val nfe_item = nfe.get
        _oprot.writeFieldBegin(NfeField)
        nfe_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Boolean] = this.success, 
      ee: Option[EngineException] = this.ee, 
      te: Option[TimeoutException] = this.te, 
      nfe: Option[NotFoundException] = this.nfe
    ): AddPostResult = new Immutable(
      success, 
      ee, 
      te, 
      nfe
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[AddPostResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 4
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => ee
      case 2 => te
      case 3 => nfe
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "AddPostResult"
  }
  
  object UserVPostArgs extends ThriftStructCodec[UserVPostArgs] {
    val Struct = new TStruct("UserVPostArgs")
    val UserIdField = new TField("userId", TType.I64, 1)
    val VerbField = new TField("verb", TType.I32, 2)
    val PostIdField = new TField("postId", TType.I64, 3)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: UserVPostArgs) {
      if (_item.verb == null) throw new TProtocolException("Required field verb cannot be null")
    }
  
    def encode(_item: UserVPostArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): UserVPostArgs = decode(_iprot)
  
    def apply(
      userId: Long,
      verb: Action,
      postId: Long
    ): UserVPostArgs = new Immutable(
      userId,
      verb,
      postId
    )
  
    def unapply(_item: UserVPostArgs): Option[Product3[Long, Action, Long]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[UserVPostArgs] {
      def encode(_item: UserVPostArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var userId: Long = 0L
        var _got_userId = false
        var verb: Action = null
        var _got_verb = false
        var postId: Long = 0L
        var _got_postId = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* userId */
                _field.`type` match {
                  case TType.I64 => {
                    userId = {
                      _iprot.readI64()
                    }
                    _got_userId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* verb */
                _field.`type` match {
                  case TType.I32 => {
                    verb = {
                      Action(_iprot.readI32())
                    }
                    _got_verb = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 3 => { /* postId */
                _field.`type` match {
                  case TType.I64 => {
                    postId = {
                      _iprot.readI64()
                    }
                    _got_postId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        if (!_got_userId) throw new TProtocolException("Required field 'UserVPostArgs' was not found in serialized data for struct UserVPostArgs")
        if (!_got_verb) throw new TProtocolException("Required field 'UserVPostArgs' was not found in serialized data for struct UserVPostArgs")
        if (!_got_postId) throw new TProtocolException("Required field 'UserVPostArgs' was not found in serialized data for struct UserVPostArgs")
        new Immutable(
          userId,
          verb,
          postId
        )
      }
    }
  
    /**
     * The default read-only implementation of UserVPostArgs.  You typically should not need to
     * directly reference this class; instead, use the UserVPostArgs.apply method to construct
     * new instances.
     */
    class Immutable(
      val userId: Long,
      val verb: Action,
      val postId: Long
    ) extends UserVPostArgs
  
  }
  
  trait UserVPostArgs extends ThriftStruct
    with Product3[Long, Action, Long]
    with java.io.Serializable
  {
    import UserVPostArgs._
  
    def userId: Long
    def verb: Action
    def postId: Long
  
    def _1 = userId
    def _2 = verb
    def _3 = postId
  
    override def write(_oprot: TProtocol) {
      UserVPostArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val userId_item = userId
        _oprot.writeFieldBegin(UserIdField)
        _oprot.writeI64(userId_item)
        _oprot.writeFieldEnd()
      }
      if (true) {
        val verb_item = verb
        _oprot.writeFieldBegin(VerbField)
        _oprot.writeI32(verb_item.value)
        _oprot.writeFieldEnd()
      }
      if (true) {
        val postId_item = postId
        _oprot.writeFieldBegin(PostIdField)
        _oprot.writeI64(postId_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      userId: Long = this.userId, 
      verb: Action = this.verb, 
      postId: Long = this.postId
    ): UserVPostArgs = new Immutable(
      userId, 
      verb, 
      postId
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[UserVPostArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 3
  
    override def productElement(n: Int): Any = n match {
      case 0 => userId
      case 1 => verb
      case 2 => postId
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "UserVPostArgs"
  }
  
  object UserVPostResult extends ThriftStructCodec[UserVPostResult] {
    val Struct = new TStruct("UserVPostResult")
    val SuccessField = new TField("success", TType.BOOL, 0)
    val NfeField = new TField("nfe", TType.STRUCT, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: UserVPostResult) {
    }
  
    def encode(_item: UserVPostResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): UserVPostResult = decode(_iprot)
  
    def apply(
      success: Option[Boolean] = None,
      nfe: Option[NotFoundException] = None
    ): UserVPostResult = new Immutable(
      success,
      nfe
    )
  
    def unapply(_item: UserVPostResult): Option[Product2[Option[Boolean], Option[NotFoundException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[UserVPostResult] {
      def encode(_item: UserVPostResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var success: Boolean = false
        var _got_success = false
        var nfe: NotFoundException = null
        var _got_nfe = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.BOOL => {
                    success = {
                      _iprot.readBool()
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* nfe */
                _field.`type` match {
                  case TType.STRUCT => {
                    nfe = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_nfe = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_nfe) Some(nfe) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of UserVPostResult.  You typically should not need to
     * directly reference this class; instead, use the UserVPostResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[Boolean] = None,
      val nfe: Option[NotFoundException] = None
    ) extends UserVPostResult
  
  }
  
  trait UserVPostResult extends ThriftStruct
    with Product2[Option[Boolean], Option[NotFoundException]]
    with java.io.Serializable
  {
    import UserVPostResult._
  
    def success: Option[Boolean]
    def nfe: Option[NotFoundException]
  
    def _1 = success
    def _2 = nfe
  
    override def write(_oprot: TProtocol) {
      UserVPostResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        _oprot.writeBool(success_item)
        _oprot.writeFieldEnd()
      }
      if (nfe.isDefined) {
        val nfe_item = nfe.get
        _oprot.writeFieldBegin(NfeField)
        nfe_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Boolean] = this.success, 
      nfe: Option[NotFoundException] = this.nfe
    ): UserVPostResult = new Immutable(
      success, 
      nfe
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[UserVPostResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => nfe
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "UserVPostResult"
  }
  
  object UserVCommentArgs extends ThriftStructCodec[UserVCommentArgs] {
    val Struct = new TStruct("UserVCommentArgs")
    val UserIdField = new TField("userId", TType.I64, 1)
    val VerbField = new TField("verb", TType.I32, 2)
    val CommentIdField = new TField("commentId", TType.I64, 3)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: UserVCommentArgs) {
      if (_item.verb == null) throw new TProtocolException("Required field verb cannot be null")
    }
  
    def encode(_item: UserVCommentArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): UserVCommentArgs = decode(_iprot)
  
    def apply(
      userId: Long,
      verb: Action,
      commentId: Long
    ): UserVCommentArgs = new Immutable(
      userId,
      verb,
      commentId
    )
  
    def unapply(_item: UserVCommentArgs): Option[Product3[Long, Action, Long]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[UserVCommentArgs] {
      def encode(_item: UserVCommentArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var userId: Long = 0L
        var _got_userId = false
        var verb: Action = null
        var _got_verb = false
        var commentId: Long = 0L
        var _got_commentId = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* userId */
                _field.`type` match {
                  case TType.I64 => {
                    userId = {
                      _iprot.readI64()
                    }
                    _got_userId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* verb */
                _field.`type` match {
                  case TType.I32 => {
                    verb = {
                      Action(_iprot.readI32())
                    }
                    _got_verb = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 3 => { /* commentId */
                _field.`type` match {
                  case TType.I64 => {
                    commentId = {
                      _iprot.readI64()
                    }
                    _got_commentId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        if (!_got_userId) throw new TProtocolException("Required field 'UserVCommentArgs' was not found in serialized data for struct UserVCommentArgs")
        if (!_got_verb) throw new TProtocolException("Required field 'UserVCommentArgs' was not found in serialized data for struct UserVCommentArgs")
        if (!_got_commentId) throw new TProtocolException("Required field 'UserVCommentArgs' was not found in serialized data for struct UserVCommentArgs")
        new Immutable(
          userId,
          verb,
          commentId
        )
      }
    }
  
    /**
     * The default read-only implementation of UserVCommentArgs.  You typically should not need to
     * directly reference this class; instead, use the UserVCommentArgs.apply method to construct
     * new instances.
     */
    class Immutable(
      val userId: Long,
      val verb: Action,
      val commentId: Long
    ) extends UserVCommentArgs
  
  }
  
  trait UserVCommentArgs extends ThriftStruct
    with Product3[Long, Action, Long]
    with java.io.Serializable
  {
    import UserVCommentArgs._
  
    def userId: Long
    def verb: Action
    def commentId: Long
  
    def _1 = userId
    def _2 = verb
    def _3 = commentId
  
    override def write(_oprot: TProtocol) {
      UserVCommentArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val userId_item = userId
        _oprot.writeFieldBegin(UserIdField)
        _oprot.writeI64(userId_item)
        _oprot.writeFieldEnd()
      }
      if (true) {
        val verb_item = verb
        _oprot.writeFieldBegin(VerbField)
        _oprot.writeI32(verb_item.value)
        _oprot.writeFieldEnd()
      }
      if (true) {
        val commentId_item = commentId
        _oprot.writeFieldBegin(CommentIdField)
        _oprot.writeI64(commentId_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      userId: Long = this.userId, 
      verb: Action = this.verb, 
      commentId: Long = this.commentId
    ): UserVCommentArgs = new Immutable(
      userId, 
      verb, 
      commentId
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[UserVCommentArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 3
  
    override def productElement(n: Int): Any = n match {
      case 0 => userId
      case 1 => verb
      case 2 => commentId
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "UserVCommentArgs"
  }
  
  object UserVCommentResult extends ThriftStructCodec[UserVCommentResult] {
    val Struct = new TStruct("UserVCommentResult")
    val SuccessField = new TField("success", TType.BOOL, 0)
    val NfeField = new TField("nfe", TType.STRUCT, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: UserVCommentResult) {
    }
  
    def encode(_item: UserVCommentResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): UserVCommentResult = decode(_iprot)
  
    def apply(
      success: Option[Boolean] = None,
      nfe: Option[NotFoundException] = None
    ): UserVCommentResult = new Immutable(
      success,
      nfe
    )
  
    def unapply(_item: UserVCommentResult): Option[Product2[Option[Boolean], Option[NotFoundException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[UserVCommentResult] {
      def encode(_item: UserVCommentResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var success: Boolean = false
        var _got_success = false
        var nfe: NotFoundException = null
        var _got_nfe = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.BOOL => {
                    success = {
                      _iprot.readBool()
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* nfe */
                _field.`type` match {
                  case TType.STRUCT => {
                    nfe = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_nfe = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_nfe) Some(nfe) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of UserVCommentResult.  You typically should not need to
     * directly reference this class; instead, use the UserVCommentResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[Boolean] = None,
      val nfe: Option[NotFoundException] = None
    ) extends UserVCommentResult
  
  }
  
  trait UserVCommentResult extends ThriftStruct
    with Product2[Option[Boolean], Option[NotFoundException]]
    with java.io.Serializable
  {
    import UserVCommentResult._
  
    def success: Option[Boolean]
    def nfe: Option[NotFoundException]
  
    def _1 = success
    def _2 = nfe
  
    override def write(_oprot: TProtocol) {
      UserVCommentResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        _oprot.writeBool(success_item)
        _oprot.writeFieldEnd()
      }
      if (nfe.isDefined) {
        val nfe_item = nfe.get
        _oprot.writeFieldBegin(NfeField)
        nfe_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Boolean] = this.success, 
      nfe: Option[NotFoundException] = this.nfe
    ): UserVCommentResult = new Immutable(
      success, 
      nfe
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[UserVCommentResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => nfe
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "UserVCommentResult"
  }
  
  object UserTopTermsArgs extends ThriftStructCodec[UserTopTermsArgs] {
    val Struct = new TStruct("UserTopTermsArgs")
    val UserIdField = new TField("userId", TType.I64, 1)
    val LimitField = new TField("limit", TType.I32, 2)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: UserTopTermsArgs) {
    }
  
    def encode(_item: UserTopTermsArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): UserTopTermsArgs = decode(_iprot)
  
    def apply(
      userId: Long,
      limit: Int
    ): UserTopTermsArgs = new Immutable(
      userId,
      limit
    )
  
    def unapply(_item: UserTopTermsArgs): Option[Product2[Long, Int]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[UserTopTermsArgs] {
      def encode(_item: UserTopTermsArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var userId: Long = 0L
        var _got_userId = false
        var limit: Int = 0
        var _got_limit = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* userId */
                _field.`type` match {
                  case TType.I64 => {
                    userId = {
                      _iprot.readI64()
                    }
                    _got_userId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* limit */
                _field.`type` match {
                  case TType.I32 => {
                    limit = {
                      _iprot.readI32()
                    }
                    _got_limit = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        if (!_got_userId) throw new TProtocolException("Required field 'UserTopTermsArgs' was not found in serialized data for struct UserTopTermsArgs")
        if (!_got_limit) throw new TProtocolException("Required field 'UserTopTermsArgs' was not found in serialized data for struct UserTopTermsArgs")
        new Immutable(
          userId,
          limit
        )
      }
    }
  
    /**
     * The default read-only implementation of UserTopTermsArgs.  You typically should not need to
     * directly reference this class; instead, use the UserTopTermsArgs.apply method to construct
     * new instances.
     */
    class Immutable(
      val userId: Long,
      val limit: Int
    ) extends UserTopTermsArgs
  
  }
  
  trait UserTopTermsArgs extends ThriftStruct
    with Product2[Long, Int]
    with java.io.Serializable
  {
    import UserTopTermsArgs._
  
    def userId: Long
    def limit: Int
  
    def _1 = userId
    def _2 = limit
  
    override def write(_oprot: TProtocol) {
      UserTopTermsArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val userId_item = userId
        _oprot.writeFieldBegin(UserIdField)
        _oprot.writeI64(userId_item)
        _oprot.writeFieldEnd()
      }
      if (true) {
        val limit_item = limit
        _oprot.writeFieldBegin(LimitField)
        _oprot.writeI32(limit_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      userId: Long = this.userId, 
      limit: Int = this.limit
    ): UserTopTermsArgs = new Immutable(
      userId, 
      limit
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[UserTopTermsArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => userId
      case 1 => limit
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "UserTopTermsArgs"
  }
  
  object UserTopTermsResult extends ThriftStructCodec[UserTopTermsResult] {
    val Struct = new TStruct("UserTopTermsResult")
    val SuccessField = new TField("success", TType.MAP, 0)
    val NfeField = new TField("nfe", TType.STRUCT, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: UserTopTermsResult) {
    }
  
    def encode(_item: UserTopTermsResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): UserTopTermsResult = decode(_iprot)
  
    def apply(
      success: Option[Map[String, Long]] = None,
      nfe: Option[NotFoundException] = None
    ): UserTopTermsResult = new Immutable(
      success,
      nfe
    )
  
    def unapply(_item: UserTopTermsResult): Option[Product2[Option[Map[String, Long]], Option[NotFoundException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[UserTopTermsResult] {
      def encode(_item: UserTopTermsResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var success: Map[String, Long] = Map[String, Long]()
        var _got_success = false
        var nfe: NotFoundException = null
        var _got_nfe = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.MAP => {
                    success = {
                      val _map = _iprot.readMapBegin()
                      val _rv = new mutable.HashMap[String, Long]
                      var _i = 0
                      while (_i < _map.size) {
                        val _key = {
                          _iprot.readString()
                        }
                        val _value = {
                          _iprot.readI64()
                        }
                        _rv(_key) = _value
                        _i += 1
                      }
                      _iprot.readMapEnd()
                      _rv
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* nfe */
                _field.`type` match {
                  case TType.STRUCT => {
                    nfe = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_nfe = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_nfe) Some(nfe) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of UserTopTermsResult.  You typically should not need to
     * directly reference this class; instead, use the UserTopTermsResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[Map[String, Long]] = None,
      val nfe: Option[NotFoundException] = None
    ) extends UserTopTermsResult
  
  }
  
  trait UserTopTermsResult extends ThriftStruct
    with Product2[Option[Map[String, Long]], Option[NotFoundException]]
    with java.io.Serializable
  {
    import UserTopTermsResult._
  
    def success: Option[Map[String, Long]]
    def nfe: Option[NotFoundException]
  
    def _1 = success
    def _2 = nfe
  
    override def write(_oprot: TProtocol) {
      UserTopTermsResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        _oprot.writeMapBegin(new TMap(TType.STRING, TType.I64, success_item.size))
        success_item.foreach { _pair =>
          val success_item_key = _pair._1
          val success_item_value = _pair._2
          _oprot.writeString(success_item_key)
          _oprot.writeI64(success_item_value)
        }
        _oprot.writeMapEnd()
        _oprot.writeFieldEnd()
      }
      if (nfe.isDefined) {
        val nfe_item = nfe.get
        _oprot.writeFieldBegin(NfeField)
        nfe_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Map[String, Long]] = this.success, 
      nfe: Option[NotFoundException] = this.nfe
    ): UserTopTermsResult = new Immutable(
      success, 
      nfe
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[UserTopTermsResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => nfe
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "UserTopTermsResult"
  }
  
  object TextSearchArgs extends ThriftStructCodec[TextSearchArgs] {
    val Struct = new TStruct("TextSearchArgs")
    val TokensField = new TField("tokens", TType.LIST, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: TextSearchArgs) {
      if (_item.tokens == null) throw new TProtocolException("Required field tokens cannot be null")
    }
  
    def encode(_item: TextSearchArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): TextSearchArgs = decode(_iprot)
  
    def apply(
      tokens: Seq[String] = Seq[String]()
    ): TextSearchArgs = new Immutable(
      tokens
    )
  
    def unapply(_item: TextSearchArgs): Option[Seq[String]] = Some(_item.tokens)
  
    object Immutable extends ThriftStructCodec[TextSearchArgs] {
      def encode(_item: TextSearchArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var tokens: Seq[String] = Seq[String]()
        var _got_tokens = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* tokens */
                _field.`type` match {
                  case TType.LIST => {
                    tokens = {
                      val _list = _iprot.readListBegin()
                      val _rv = new mutable.ArrayBuffer[String](_list.size)
                      var _i = 0
                      while (_i < _list.size) {
                        _rv += {
                          _iprot.readString()
                        }
                        _i += 1
                      }
                      _iprot.readListEnd()
                      _rv
                    }
                    _got_tokens = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        if (!_got_tokens) throw new TProtocolException("Required field 'TextSearchArgs' was not found in serialized data for struct TextSearchArgs")
        new Immutable(
          tokens
        )
      }
    }
  
    /**
     * The default read-only implementation of TextSearchArgs.  You typically should not need to
     * directly reference this class; instead, use the TextSearchArgs.apply method to construct
     * new instances.
     */
    class Immutable(
      val tokens: Seq[String] = Seq[String]()
    ) extends TextSearchArgs
  
  }
  
  trait TextSearchArgs extends ThriftStruct
    with Product1[Seq[String]]
    with java.io.Serializable
  {
    import TextSearchArgs._
  
    def tokens: Seq[String]
  
    def _1 = tokens
  
    override def write(_oprot: TProtocol) {
      TextSearchArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val tokens_item = tokens
        _oprot.writeFieldBegin(TokensField)
        _oprot.writeListBegin(new TList(TType.STRING, tokens_item.size))
        tokens_item.foreach { tokens_item_element =>
          _oprot.writeString(tokens_item_element)
        }
        _oprot.writeListEnd()
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      tokens: Seq[String] = this.tokens
    ): TextSearchArgs = new Immutable(
      tokens
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[TextSearchArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => tokens
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "TextSearchArgs"
  }
  
  object TextSearchResult extends ThriftStructCodec[TextSearchResult] {
    val Struct = new TStruct("TextSearchResult")
    val SuccessField = new TField("success", TType.MAP, 0)
    val EeField = new TField("ee", TType.STRUCT, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: TextSearchResult) {
    }
  
    def encode(_item: TextSearchResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): TextSearchResult = decode(_iprot)
  
    def apply(
      success: Option[Map[Long, Double]] = None,
      ee: Option[EngineException] = None
    ): TextSearchResult = new Immutable(
      success,
      ee
    )
  
    def unapply(_item: TextSearchResult): Option[Product2[Option[Map[Long, Double]], Option[EngineException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[TextSearchResult] {
      def encode(_item: TextSearchResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var success: Map[Long, Double] = Map[Long, Double]()
        var _got_success = false
        var ee: EngineException = null
        var _got_ee = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.MAP => {
                    success = {
                      val _map = _iprot.readMapBegin()
                      val _rv = new mutable.HashMap[Long, Double]
                      var _i = 0
                      while (_i < _map.size) {
                        val _key = {
                          _iprot.readI64()
                        }
                        val _value = {
                          _iprot.readDouble()
                        }
                        _rv(_key) = _value
                        _i += 1
                      }
                      _iprot.readMapEnd()
                      _rv
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* ee */
                _field.`type` match {
                  case TType.STRUCT => {
                    ee = {
                      EngineException.decode(_iprot)
                    }
                    _got_ee = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_ee) Some(ee) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of TextSearchResult.  You typically should not need to
     * directly reference this class; instead, use the TextSearchResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[Map[Long, Double]] = None,
      val ee: Option[EngineException] = None
    ) extends TextSearchResult
  
  }
  
  trait TextSearchResult extends ThriftStruct
    with Product2[Option[Map[Long, Double]], Option[EngineException]]
    with java.io.Serializable
  {
    import TextSearchResult._
  
    def success: Option[Map[Long, Double]]
    def ee: Option[EngineException]
  
    def _1 = success
    def _2 = ee
  
    override def write(_oprot: TProtocol) {
      TextSearchResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        _oprot.writeMapBegin(new TMap(TType.I64, TType.DOUBLE, success_item.size))
        success_item.foreach { _pair =>
          val success_item_key = _pair._1
          val success_item_value = _pair._2
          _oprot.writeI64(success_item_key)
          _oprot.writeDouble(success_item_value)
        }
        _oprot.writeMapEnd()
        _oprot.writeFieldEnd()
      }
      if (ee.isDefined) {
        val ee_item = ee.get
        _oprot.writeFieldBegin(EeField)
        ee_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Map[Long, Double]] = this.success, 
      ee: Option[EngineException] = this.ee
    ): TextSearchResult = new Immutable(
      success, 
      ee
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[TextSearchResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => ee
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "TextSearchResult"
  }
  
  class FinagledClient(
    val service: FinagleService[ThriftClientRequest, Array[Byte]],
    val protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
    val serviceName: String = "",
    stats: StatsReceiver = NullStatsReceiver
  ) extends FutureIface {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected def encodeRequest(name: String, args: ThriftStruct) = {
      val buf = new TMemoryBuffer(512)
      val oprot = protocolFactory.getProtocol(buf)
  
      oprot.writeMessageBegin(new TMessage(name, TMessageType.CALL, 0))
      args.write(oprot)
      oprot.writeMessageEnd()
  
      val bytes = Arrays.copyOfRange(buf.getArray, 0, buf.length)
      new ThriftClientRequest(bytes, false)
    }
  
    protected def decodeResponse[T <: ThriftStruct](resBytes: Array[Byte], codec: ThriftStructCodec[T]) = {
      val iprot = protocolFactory.getProtocol(new TMemoryInputTransport(resBytes))
      val msg = iprot.readMessageBegin()
      try {
        if (msg.`type` == TMessageType.EXCEPTION) {
          val exception = TApplicationException.read(iprot) match {
            case sourced: SourcedException =>
              if (serviceName != "") sourced.serviceName = serviceName
              sourced
            case e => e
          }
          throw exception
        } else {
          codec.decode(iprot)
        }
      } finally {
        iprot.readMessageEnd()
      }
    }
  
    protected def missingResult(name: String) = {
      new TApplicationException(
        TApplicationException.MISSING_RESULT,
        name + " failed: unknown result"
      )
    }
  
    // ----- end boilerplate.
  
    private[this] val scopedStats = if (serviceName != "") stats.scope(serviceName) else stats
    private[this] object __stats_ping {
      val RequestsCounter = scopedStats.scope("ping").counter("requests")
      val SuccessCounter = scopedStats.scope("ping").counter("success")
      val FailuresCounter = scopedStats.scope("ping").counter("failures")
      val FailuresScope = scopedStats.scope("ping").scope("failures")
    }
  
    /** Test for connectivity */
    def ping(): Future[String] = {
      __stats_ping.RequestsCounter.incr()
      this.service(encodeRequest("ping", PingArgs())) flatMap { response =>
        val result = decodeResponse(response, PingResult)
        val exception =
          (result.te).map(Future.exception)
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("ping")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_ping.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_ping.FailuresCounter.incr()
        __stats_ping.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_recPosts {
      val RequestsCounter = scopedStats.scope("recPosts").counter("requests")
      val SuccessCounter = scopedStats.scope("recPosts").counter("success")
      val FailuresCounter = scopedStats.scope("recPosts").counter("failures")
      val FailuresScope = scopedStats.scope("recPosts").scope("failures")
    }
  
    /** Request a list of posts that are most appropriate for a user
         * @param user_id, the user that the posts are being requested for
         */
    def recPosts(userId: Long): Future[PostList] = {
      __stats_recPosts.RequestsCounter.incr()
      this.service(encodeRequest("recPosts", RecPostsArgs(userId))) flatMap { response =>
        val result = decodeResponse(response, RecPostsResult)
        val exception =
          (result.nfe orElse result.ee orElse result.te).map(Future.exception)
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("recPosts")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_recPosts.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_recPosts.FailuresCounter.incr()
        __stats_recPosts.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_addUser {
      val RequestsCounter = scopedStats.scope("addUser").counter("requests")
      val SuccessCounter = scopedStats.scope("addUser").counter("success")
      val FailuresCounter = scopedStats.scope("addUser").counter("failures")
      val FailuresScope = scopedStats.scope("addUser").scope("failures")
    }
  
    /** Informs the backend that a new user has been created
         * @param user_id, the user that is being added
         */
    def addUser(userId: Long): Future[Boolean] = {
      __stats_addUser.RequestsCounter.incr()
      this.service(encodeRequest("addUser", AddUserArgs(userId))) flatMap { response =>
        val result = decodeResponse(response, AddUserResult)
        val exception =
          (result.ee orElse result.te).map(Future.exception)
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("addUser")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_addUser.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_addUser.FailuresCounter.incr()
        __stats_addUser.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_addPost {
      val RequestsCounter = scopedStats.scope("addPost").counter("requests")
      val SuccessCounter = scopedStats.scope("addPost").counter("success")
      val FailuresCounter = scopedStats.scope("addPost").counter("failures")
      val FailuresScope = scopedStats.scope("addPost").scope("failures")
    }
  
    /** Informs the backedn that a user has submitted a post
         * @param user_id, the user that submitted the post
         * @param post_id, the post the user submitted
         * @param raw_freq, a list of <token, freq> pairs that correspond to the number of times a keyword is in a post.
         */
    def addPost(userId: Long, postId: Long, rawFreq: Seq[Token] = Seq[Token]()): Future[Boolean] = {
      __stats_addPost.RequestsCounter.incr()
      this.service(encodeRequest("addPost", AddPostArgs(userId, postId, rawFreq))) flatMap { response =>
        val result = decodeResponse(response, AddPostResult)
        val exception =
          (result.ee orElse result.te orElse result.nfe).map(Future.exception)
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("addPost")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_addPost.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_addPost.FailuresCounter.incr()
        __stats_addPost.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_userVPost {
      val RequestsCounter = scopedStats.scope("userVPost").counter("requests")
      val SuccessCounter = scopedStats.scope("userVPost").counter("success")
      val FailuresCounter = scopedStats.scope("userVPost").counter("failures")
      val FailuresScope = scopedStats.scope("userVPost").scope("failures")
    }
  
    /** Alert the recommender that a user has actioned a post
         * @param user_id, the user that performed the action
         * @param verb, the action taken (this is from the Action enum)
         * @param post_id, the post that the action is being performed on
         */
    def userVPost(userId: Long, verb: Action, postId: Long): Future[Boolean] = {
      __stats_userVPost.RequestsCounter.incr()
      this.service(encodeRequest("userVPost", UserVPostArgs(userId, verb, postId))) flatMap { response =>
        val result = decodeResponse(response, UserVPostResult)
        val exception =
          (result.nfe).map(Future.exception)
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("userVPost")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_userVPost.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_userVPost.FailuresCounter.incr()
        __stats_userVPost.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_userVComment {
      val RequestsCounter = scopedStats.scope("userVComment").counter("requests")
      val SuccessCounter = scopedStats.scope("userVComment").counter("success")
      val FailuresCounter = scopedStats.scope("userVComment").counter("failures")
      val FailuresScope = scopedStats.scope("userVComment").scope("failures")
    }
  
    /** Alert the recommender that a user has actioned a comment
         * @param user_id, the user that performed the action
         * @param verb, the action taken (this is from the Action enum)
         * @param comment_id, the comment that the action is being performed on
         */
    def userVComment(userId: Long, verb: Action, commentId: Long): Future[Boolean] = {
      __stats_userVComment.RequestsCounter.incr()
      this.service(encodeRequest("userVComment", UserVCommentArgs(userId, verb, commentId))) flatMap { response =>
        val result = decodeResponse(response, UserVCommentResult)
        val exception =
          (result.nfe).map(Future.exception)
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("userVComment")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_userVComment.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_userVComment.FailuresCounter.incr()
        __stats_userVComment.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_userTopTerms {
      val RequestsCounter = scopedStats.scope("userTopTerms").counter("requests")
      val SuccessCounter = scopedStats.scope("userTopTerms").counter("success")
      val FailuresCounter = scopedStats.scope("userTopTerms").counter("failures")
      val FailuresScope = scopedStats.scope("userTopTerms").scope("failures")
    }
  
    /** Return the list of top n tokens for a user
         * @param user_id, the user to query for
         * @param limit, the maximum amount of tokens to return 
         */
    def userTopTerms(userId: Long, limit: Int): Future[Map[String, Long]] = {
      __stats_userTopTerms.RequestsCounter.incr()
      this.service(encodeRequest("userTopTerms", UserTopTermsArgs(userId, limit))) flatMap { response =>
        val result = decodeResponse(response, UserTopTermsResult)
        val exception =
          (result.nfe).map(Future.exception)
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("userTopTerms")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_userTopTerms.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_userTopTerms.FailuresCounter.incr()
        __stats_userTopTerms.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_textSearch {
      val RequestsCounter = scopedStats.scope("textSearch").counter("requests")
      val SuccessCounter = scopedStats.scope("textSearch").counter("success")
      val FailuresCounter = scopedStats.scope("textSearch").counter("failures")
      val FailuresScope = scopedStats.scope("textSearch").scope("failures")
    }
  
    /** Return a list of documents in sorted order of relevance for a search query
         * @param query, a map of tokens to their weight
         */
    def textSearch(tokens: Seq[String] = Seq[String]()): Future[Map[Long, Double]] = {
      __stats_textSearch.RequestsCounter.incr()
      this.service(encodeRequest("textSearch", TextSearchArgs(tokens))) flatMap { response =>
        val result = decodeResponse(response, TextSearchResult)
        val exception =
          (result.ee).map(Future.exception)
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("textSearch")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_textSearch.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_textSearch.FailuresCounter.incr()
        __stats_textSearch.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
  }
  
  class FinagledService(
    iface: FutureIface,
    protocolFactory: TProtocolFactory
  ) extends FinagleService[Array[Byte], Array[Byte]] {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected val functionMap = new mutable.HashMap[String, (TProtocol, Int) => Future[Array[Byte]]]()
  
    protected def addFunction(name: String, f: (TProtocol, Int) => Future[Array[Byte]]) {
      functionMap(name) = f
    }
  
    protected def exception(name: String, seqid: Int, code: Int, message: String): Future[Array[Byte]] = {
      try {
        val x = new TApplicationException(code, message)
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.EXCEPTION, seqid))
        x.write(oprot)
        oprot.writeMessageEnd()
        oprot.getTransport().flush()
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    protected def reply(name: String, seqid: Int, result: ThriftStruct): Future[Array[Byte]] = {
      try {
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.REPLY, seqid))
        result.write(oprot)
        oprot.writeMessageEnd()
  
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    final def apply(request: Array[Byte]): Future[Array[Byte]] = {
      val inputTransport = new TMemoryInputTransport(request)
      val iprot = protocolFactory.getProtocol(inputTransport)
  
      try {
        val msg = iprot.readMessageBegin()
        functionMap.get(msg.name) map { _.apply(iprot, msg.seqid) } getOrElse {
          TProtocolUtil.skip(iprot, TType.STRUCT)
          exception(msg.name, msg.seqid, TApplicationException.UNKNOWN_METHOD,
            "Invalid method name: '" + msg.name + "'")
        }
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    // ---- end boilerplate.
  
    addFunction("ping", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = PingArgs.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.ping()
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: String =>
          reply("ping", seqid, PingResult(success = Some(value)))
        } rescue {
          case e: TimeoutException => {
            reply("ping", seqid, PingResult(te = Some(e)))
          }
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("ping", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("recPosts", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = RecPostsArgs.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.recPosts(args.userId)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: PostList =>
          reply("recPosts", seqid, RecPostsResult(success = Some(value)))
        } rescue {
          case e: NotFoundException => {
            reply("recPosts", seqid, RecPostsResult(nfe = Some(e)))
          }
          case e: EngineException => {
            reply("recPosts", seqid, RecPostsResult(ee = Some(e)))
          }
          case e: TimeoutException => {
            reply("recPosts", seqid, RecPostsResult(te = Some(e)))
          }
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("recPosts", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("addUser", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = AddUserArgs.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.addUser(args.userId)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Boolean =>
          reply("addUser", seqid, AddUserResult(success = Some(value)))
        } rescue {
          case e: EngineException => {
            reply("addUser", seqid, AddUserResult(ee = Some(e)))
          }
          case e: TimeoutException => {
            reply("addUser", seqid, AddUserResult(te = Some(e)))
          }
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("addUser", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("addPost", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = AddPostArgs.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.addPost(args.userId, args.postId, args.rawFreq)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Boolean =>
          reply("addPost", seqid, AddPostResult(success = Some(value)))
        } rescue {
          case e: EngineException => {
            reply("addPost", seqid, AddPostResult(ee = Some(e)))
          }
          case e: TimeoutException => {
            reply("addPost", seqid, AddPostResult(te = Some(e)))
          }
          case e: NotFoundException => {
            reply("addPost", seqid, AddPostResult(nfe = Some(e)))
          }
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("addPost", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("userVPost", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = UserVPostArgs.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.userVPost(args.userId, args.verb, args.postId)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Boolean =>
          reply("userVPost", seqid, UserVPostResult(success = Some(value)))
        } rescue {
          case e: NotFoundException => {
            reply("userVPost", seqid, UserVPostResult(nfe = Some(e)))
          }
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("userVPost", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("userVComment", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = UserVCommentArgs.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.userVComment(args.userId, args.verb, args.commentId)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Boolean =>
          reply("userVComment", seqid, UserVCommentResult(success = Some(value)))
        } rescue {
          case e: NotFoundException => {
            reply("userVComment", seqid, UserVCommentResult(nfe = Some(e)))
          }
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("userVComment", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("userTopTerms", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = UserTopTermsArgs.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.userTopTerms(args.userId, args.limit)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Map[String, Long] =>
          reply("userTopTerms", seqid, UserTopTermsResult(success = Some(value)))
        } rescue {
          case e: NotFoundException => {
            reply("userTopTerms", seqid, UserTopTermsResult(nfe = Some(e)))
          }
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("userTopTerms", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("textSearch", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = TextSearchArgs.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.textSearch(args.tokens)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Map[Long, Double] =>
          reply("textSearch", seqid, TextSearchResult(success = Some(value)))
        } rescue {
          case e: EngineException => {
            reply("textSearch", seqid, TextSearchResult(ee = Some(e)))
          }
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("textSearch", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
  }
}