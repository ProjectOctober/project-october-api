/**
 * generated by Scrooge 3.0.5-SNAPSHOT
 */
package october

import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec}
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import scala.collection.mutable
import scala.collection.{Map, Set}
import com.twitter.util.Future
import com.twitter.conversions.time._
import com.twitter.finagle.{Service => FinagleService}
import com.twitter.finagle.stats.{NullStatsReceiver, StatsReceiver}
import com.twitter.finagle.thrift.ThriftClientRequest
import com.twitter.finagle.SourcedException
import com.twitter.finagle.{Service => FinagleService}
import java.util.Arrays
import org.apache.thrift.transport.{TMemoryBuffer, TMemoryInputTransport, TTransport}


object Recommender {
  trait Iface {
    /** Test for connectivity */
    @throws(classOf[TimeoutException])
    def ping(): String
    /** Request a list of posts that are most appropriate for a user
         * @param user_id, the user that the posts are being requested for
         */
    @throws(classOf[NotFoundException])
    @throws(classOf[EngineException])
    @throws(classOf[TimeoutException])
    def recPosts(userId: Long): PostList
    /** Alert the recommender that a user has actioned a post
         * @param user_id, the user that performed the action
         * @param verb, the action taken (this is from the Action enum)
         * @param post_id, the post that the action is being performed on
         */
    @throws(classOf[NotFoundException])
    def userVPost(userId: Long, verb: Action, postId: Long): Unit
    /** Alert the recommender that a user has actioned a comment
         * @param user_id, the user that performed the action
         * @param verb, the action taken (this is from the Action enum)
         * @param comment_id, the comment that the action is being performed on
         */
    @throws(classOf[NotFoundException])
    def userVComment(userId: Long, verb: Action, commentId: Long): Unit
  }

  trait FutureIface {
    /** Test for connectivity */
    def ping(): Future[String]
    /** Request a list of posts that are most appropriate for a user
         * @param user_id, the user that the posts are being requested for
         */
    def recPosts(userId: Long): Future[PostList]
    /** Alert the recommender that a user has actioned a post
         * @param user_id, the user that performed the action
         * @param verb, the action taken (this is from the Action enum)
         * @param post_id, the post that the action is being performed on
         */
    def userVPost(userId: Long, verb: Action, postId: Long): Future[Unit]
    /** Alert the recommender that a user has actioned a comment
         * @param user_id, the user that performed the action
         * @param verb, the action taken (this is from the Action enum)
         * @param comment_id, the comment that the action is being performed on
         */
    def userVComment(userId: Long, verb: Action, commentId: Long): Future[Unit]
  }

  
  object PingArgs extends ThriftStructCodec[PingArgs] {
    val Struct = new TStruct("PingArgs")
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: PingArgs) {
    }
  
    def encode(_item: PingArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): PingArgs = decode(_iprot)
  
    def apply(
    ): PingArgs = new Immutable(
    )
  
    def unapply(_item: PingArgs): Boolean = true
  
    object Immutable extends ThriftStructCodec[PingArgs] {
      def encode(_item: PingArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
        )
      }
    }
  
    /**
     * The default read-only implementation of PingArgs.  You typically should not need to
     * directly reference this class; instead, use the PingArgs.apply method to construct
     * new instances.
     */
    class Immutable(
    ) extends PingArgs
  
  }
  
  trait PingArgs extends ThriftStruct
    with Product
    with java.io.Serializable
  {
    import PingArgs._
  
  
  
    override def write(_oprot: TProtocol) {
      PingArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
    ): PingArgs = new Immutable(
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[PingArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "PingArgs"
  }
  
  object PingResult extends ThriftStructCodec[PingResult] {
    val Struct = new TStruct("PingResult")
    val SuccessField = new TField("success", TType.STRING, 0)
    val TeField = new TField("te", TType.STRUCT, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: PingResult) {
    }
  
    def encode(_item: PingResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): PingResult = decode(_iprot)
  
    def apply(
      success: Option[String] = None,
      te: Option[TimeoutException] = None
    ): PingResult = new Immutable(
      success,
      te
    )
  
    def unapply(_item: PingResult): Option[Product2[Option[String], Option[TimeoutException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[PingResult] {
      def encode(_item: PingResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var success: String = null
        var _got_success = false
        var te: TimeoutException = null
        var _got_te = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRING => {
                    success = {
                      _iprot.readString()
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* te */
                _field.`type` match {
                  case TType.STRUCT => {
                    te = {
                      TimeoutException.decode(_iprot)
                    }
                    _got_te = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_te) Some(te) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of PingResult.  You typically should not need to
     * directly reference this class; instead, use the PingResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[String] = None,
      val te: Option[TimeoutException] = None
    ) extends PingResult
  
  }
  
  trait PingResult extends ThriftStruct
    with Product2[Option[String], Option[TimeoutException]]
    with java.io.Serializable
  {
    import PingResult._
  
    def success: Option[String]
    def te: Option[TimeoutException]
  
    def _1 = success
    def _2 = te
  
    override def write(_oprot: TProtocol) {
      PingResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        _oprot.writeString(success_item)
        _oprot.writeFieldEnd()
      }
      if (te.isDefined) {
        val te_item = te.get
        _oprot.writeFieldBegin(TeField)
        te_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[String] = this.success, 
      te: Option[TimeoutException] = this.te
    ): PingResult = new Immutable(
      success, 
      te
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[PingResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => te
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "PingResult"
  }
  
  object RecPostsArgs extends ThriftStructCodec[RecPostsArgs] {
    val Struct = new TStruct("RecPostsArgs")
    val UserIdField = new TField("userId", TType.I64, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: RecPostsArgs) {
    }
  
    def encode(_item: RecPostsArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): RecPostsArgs = decode(_iprot)
  
    def apply(
      userId: Long
    ): RecPostsArgs = new Immutable(
      userId
    )
  
    def unapply(_item: RecPostsArgs): Option[Long] = Some(_item.userId)
  
    object Immutable extends ThriftStructCodec[RecPostsArgs] {
      def encode(_item: RecPostsArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var userId: Long = 0L
        var _got_userId = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* userId */
                _field.`type` match {
                  case TType.I64 => {
                    userId = {
                      _iprot.readI64()
                    }
                    _got_userId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        if (!_got_userId) throw new TProtocolException("Required field 'RecPostsArgs' was not found in serialized data for struct RecPostsArgs")
        new Immutable(
          userId
        )
      }
    }
  
    /**
     * The default read-only implementation of RecPostsArgs.  You typically should not need to
     * directly reference this class; instead, use the RecPostsArgs.apply method to construct
     * new instances.
     */
    class Immutable(
      val userId: Long
    ) extends RecPostsArgs
  
  }
  
  trait RecPostsArgs extends ThriftStruct
    with Product1[Long]
    with java.io.Serializable
  {
    import RecPostsArgs._
  
    def userId: Long
  
    def _1 = userId
  
    override def write(_oprot: TProtocol) {
      RecPostsArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val userId_item = userId
        _oprot.writeFieldBegin(UserIdField)
        _oprot.writeI64(userId_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      userId: Long = this.userId
    ): RecPostsArgs = new Immutable(
      userId
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[RecPostsArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => userId
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "RecPostsArgs"
  }
  
  object RecPostsResult extends ThriftStructCodec[RecPostsResult] {
    val Struct = new TStruct("RecPostsResult")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val NfeField = new TField("nfe", TType.STRUCT, 1)
    val EeField = new TField("ee", TType.STRUCT, 2)
    val TeField = new TField("te", TType.STRUCT, 3)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: RecPostsResult) {
    }
  
    def encode(_item: RecPostsResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): RecPostsResult = decode(_iprot)
  
    def apply(
      success: Option[PostList] = None,
      nfe: Option[NotFoundException] = None,
      ee: Option[EngineException] = None,
      te: Option[TimeoutException] = None
    ): RecPostsResult = new Immutable(
      success,
      nfe,
      ee,
      te
    )
  
    def unapply(_item: RecPostsResult): Option[Product4[Option[PostList], Option[NotFoundException], Option[EngineException], Option[TimeoutException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[RecPostsResult] {
      def encode(_item: RecPostsResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var success: PostList = null
        var _got_success = false
        var nfe: NotFoundException = null
        var _got_nfe = false
        var ee: EngineException = null
        var _got_ee = false
        var te: TimeoutException = null
        var _got_te = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      PostList.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* nfe */
                _field.`type` match {
                  case TType.STRUCT => {
                    nfe = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_nfe = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* ee */
                _field.`type` match {
                  case TType.STRUCT => {
                    ee = {
                      EngineException.decode(_iprot)
                    }
                    _got_ee = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 3 => { /* te */
                _field.`type` match {
                  case TType.STRUCT => {
                    te = {
                      TimeoutException.decode(_iprot)
                    }
                    _got_te = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_nfe) Some(nfe) else None,
          if (_got_ee) Some(ee) else None,
          if (_got_te) Some(te) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of RecPostsResult.  You typically should not need to
     * directly reference this class; instead, use the RecPostsResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[PostList] = None,
      val nfe: Option[NotFoundException] = None,
      val ee: Option[EngineException] = None,
      val te: Option[TimeoutException] = None
    ) extends RecPostsResult
  
  }
  
  trait RecPostsResult extends ThriftStruct
    with Product4[Option[PostList], Option[NotFoundException], Option[EngineException], Option[TimeoutException]]
    with java.io.Serializable
  {
    import RecPostsResult._
  
    def success: Option[PostList]
    def nfe: Option[NotFoundException]
    def ee: Option[EngineException]
    def te: Option[TimeoutException]
  
    def _1 = success
    def _2 = nfe
    def _3 = ee
    def _4 = te
  
    override def write(_oprot: TProtocol) {
      RecPostsResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (nfe.isDefined) {
        val nfe_item = nfe.get
        _oprot.writeFieldBegin(NfeField)
        nfe_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (ee.isDefined) {
        val ee_item = ee.get
        _oprot.writeFieldBegin(EeField)
        ee_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (te.isDefined) {
        val te_item = te.get
        _oprot.writeFieldBegin(TeField)
        te_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[PostList] = this.success, 
      nfe: Option[NotFoundException] = this.nfe, 
      ee: Option[EngineException] = this.ee, 
      te: Option[TimeoutException] = this.te
    ): RecPostsResult = new Immutable(
      success, 
      nfe, 
      ee, 
      te
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[RecPostsResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 4
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => nfe
      case 2 => ee
      case 3 => te
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "RecPostsResult"
  }
  
  object UserVPostArgs extends ThriftStructCodec[UserVPostArgs] {
    val Struct = new TStruct("UserVPostArgs")
    val UserIdField = new TField("userId", TType.I64, 1)
    val VerbField = new TField("verb", TType.I32, 2)
    val PostIdField = new TField("postId", TType.I64, 3)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: UserVPostArgs) {
      if (_item.verb == null) throw new TProtocolException("Required field verb cannot be null")
    }
  
    def encode(_item: UserVPostArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): UserVPostArgs = decode(_iprot)
  
    def apply(
      userId: Long,
      verb: Action,
      postId: Long
    ): UserVPostArgs = new Immutable(
      userId,
      verb,
      postId
    )
  
    def unapply(_item: UserVPostArgs): Option[Product3[Long, Action, Long]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[UserVPostArgs] {
      def encode(_item: UserVPostArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var userId: Long = 0L
        var _got_userId = false
        var verb: Action = null
        var _got_verb = false
        var postId: Long = 0L
        var _got_postId = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* userId */
                _field.`type` match {
                  case TType.I64 => {
                    userId = {
                      _iprot.readI64()
                    }
                    _got_userId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* verb */
                _field.`type` match {
                  case TType.I32 => {
                    verb = {
                      Action(_iprot.readI32())
                    }
                    _got_verb = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 3 => { /* postId */
                _field.`type` match {
                  case TType.I64 => {
                    postId = {
                      _iprot.readI64()
                    }
                    _got_postId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        if (!_got_userId) throw new TProtocolException("Required field 'UserVPostArgs' was not found in serialized data for struct UserVPostArgs")
        if (!_got_verb) throw new TProtocolException("Required field 'UserVPostArgs' was not found in serialized data for struct UserVPostArgs")
        if (!_got_postId) throw new TProtocolException("Required field 'UserVPostArgs' was not found in serialized data for struct UserVPostArgs")
        new Immutable(
          userId,
          verb,
          postId
        )
      }
    }
  
    /**
     * The default read-only implementation of UserVPostArgs.  You typically should not need to
     * directly reference this class; instead, use the UserVPostArgs.apply method to construct
     * new instances.
     */
    class Immutable(
      val userId: Long,
      val verb: Action,
      val postId: Long
    ) extends UserVPostArgs
  
  }
  
  trait UserVPostArgs extends ThriftStruct
    with Product3[Long, Action, Long]
    with java.io.Serializable
  {
    import UserVPostArgs._
  
    def userId: Long
    def verb: Action
    def postId: Long
  
    def _1 = userId
    def _2 = verb
    def _3 = postId
  
    override def write(_oprot: TProtocol) {
      UserVPostArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val userId_item = userId
        _oprot.writeFieldBegin(UserIdField)
        _oprot.writeI64(userId_item)
        _oprot.writeFieldEnd()
      }
      if (true) {
        val verb_item = verb
        _oprot.writeFieldBegin(VerbField)
        _oprot.writeI32(verb_item.value)
        _oprot.writeFieldEnd()
      }
      if (true) {
        val postId_item = postId
        _oprot.writeFieldBegin(PostIdField)
        _oprot.writeI64(postId_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      userId: Long = this.userId, 
      verb: Action = this.verb, 
      postId: Long = this.postId
    ): UserVPostArgs = new Immutable(
      userId, 
      verb, 
      postId
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[UserVPostArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 3
  
    override def productElement(n: Int): Any = n match {
      case 0 => userId
      case 1 => verb
      case 2 => postId
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "UserVPostArgs"
  }
  
  object UserVPostResult extends ThriftStructCodec[UserVPostResult] {
    val Struct = new TStruct("UserVPostResult")
    val NfeField = new TField("nfe", TType.STRUCT, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: UserVPostResult) {
    }
  
    def encode(_item: UserVPostResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): UserVPostResult = decode(_iprot)
  
    def apply(
      nfe: Option[NotFoundException] = None
    ): UserVPostResult = new Immutable(
      nfe
    )
  
    def unapply(_item: UserVPostResult): Option[Option[NotFoundException]] = Some(_item.nfe)
  
    object Immutable extends ThriftStructCodec[UserVPostResult] {
      def encode(_item: UserVPostResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var nfe: NotFoundException = null
        var _got_nfe = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* nfe */
                _field.`type` match {
                  case TType.STRUCT => {
                    nfe = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_nfe = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_nfe) Some(nfe) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of UserVPostResult.  You typically should not need to
     * directly reference this class; instead, use the UserVPostResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val nfe: Option[NotFoundException] = None
    ) extends UserVPostResult
  
  }
  
  trait UserVPostResult extends ThriftStruct
    with Product1[Option[NotFoundException]]
    with java.io.Serializable
  {
    import UserVPostResult._
  
    def nfe: Option[NotFoundException]
  
    def _1 = nfe
  
    override def write(_oprot: TProtocol) {
      UserVPostResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (nfe.isDefined) {
        val nfe_item = nfe.get
        _oprot.writeFieldBegin(NfeField)
        nfe_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      nfe: Option[NotFoundException] = this.nfe
    ): UserVPostResult = new Immutable(
      nfe
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[UserVPostResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => nfe
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "UserVPostResult"
  }
  
  object UserVCommentArgs extends ThriftStructCodec[UserVCommentArgs] {
    val Struct = new TStruct("UserVCommentArgs")
    val UserIdField = new TField("userId", TType.I64, 1)
    val VerbField = new TField("verb", TType.I32, 2)
    val CommentIdField = new TField("commentId", TType.I64, 3)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: UserVCommentArgs) {
      if (_item.verb == null) throw new TProtocolException("Required field verb cannot be null")
    }
  
    def encode(_item: UserVCommentArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): UserVCommentArgs = decode(_iprot)
  
    def apply(
      userId: Long,
      verb: Action,
      commentId: Long
    ): UserVCommentArgs = new Immutable(
      userId,
      verb,
      commentId
    )
  
    def unapply(_item: UserVCommentArgs): Option[Product3[Long, Action, Long]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[UserVCommentArgs] {
      def encode(_item: UserVCommentArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var userId: Long = 0L
        var _got_userId = false
        var verb: Action = null
        var _got_verb = false
        var commentId: Long = 0L
        var _got_commentId = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* userId */
                _field.`type` match {
                  case TType.I64 => {
                    userId = {
                      _iprot.readI64()
                    }
                    _got_userId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* verb */
                _field.`type` match {
                  case TType.I32 => {
                    verb = {
                      Action(_iprot.readI32())
                    }
                    _got_verb = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 3 => { /* commentId */
                _field.`type` match {
                  case TType.I64 => {
                    commentId = {
                      _iprot.readI64()
                    }
                    _got_commentId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        if (!_got_userId) throw new TProtocolException("Required field 'UserVCommentArgs' was not found in serialized data for struct UserVCommentArgs")
        if (!_got_verb) throw new TProtocolException("Required field 'UserVCommentArgs' was not found in serialized data for struct UserVCommentArgs")
        if (!_got_commentId) throw new TProtocolException("Required field 'UserVCommentArgs' was not found in serialized data for struct UserVCommentArgs")
        new Immutable(
          userId,
          verb,
          commentId
        )
      }
    }
  
    /**
     * The default read-only implementation of UserVCommentArgs.  You typically should not need to
     * directly reference this class; instead, use the UserVCommentArgs.apply method to construct
     * new instances.
     */
    class Immutable(
      val userId: Long,
      val verb: Action,
      val commentId: Long
    ) extends UserVCommentArgs
  
  }
  
  trait UserVCommentArgs extends ThriftStruct
    with Product3[Long, Action, Long]
    with java.io.Serializable
  {
    import UserVCommentArgs._
  
    def userId: Long
    def verb: Action
    def commentId: Long
  
    def _1 = userId
    def _2 = verb
    def _3 = commentId
  
    override def write(_oprot: TProtocol) {
      UserVCommentArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val userId_item = userId
        _oprot.writeFieldBegin(UserIdField)
        _oprot.writeI64(userId_item)
        _oprot.writeFieldEnd()
      }
      if (true) {
        val verb_item = verb
        _oprot.writeFieldBegin(VerbField)
        _oprot.writeI32(verb_item.value)
        _oprot.writeFieldEnd()
      }
      if (true) {
        val commentId_item = commentId
        _oprot.writeFieldBegin(CommentIdField)
        _oprot.writeI64(commentId_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      userId: Long = this.userId, 
      verb: Action = this.verb, 
      commentId: Long = this.commentId
    ): UserVCommentArgs = new Immutable(
      userId, 
      verb, 
      commentId
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[UserVCommentArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 3
  
    override def productElement(n: Int): Any = n match {
      case 0 => userId
      case 1 => verb
      case 2 => commentId
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "UserVCommentArgs"
  }
  
  object UserVCommentResult extends ThriftStructCodec[UserVCommentResult] {
    val Struct = new TStruct("UserVCommentResult")
    val NfeField = new TField("nfe", TType.STRUCT, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: UserVCommentResult) {
    }
  
    def encode(_item: UserVCommentResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): UserVCommentResult = decode(_iprot)
  
    def apply(
      nfe: Option[NotFoundException] = None
    ): UserVCommentResult = new Immutable(
      nfe
    )
  
    def unapply(_item: UserVCommentResult): Option[Option[NotFoundException]] = Some(_item.nfe)
  
    object Immutable extends ThriftStructCodec[UserVCommentResult] {
      def encode(_item: UserVCommentResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var nfe: NotFoundException = null
        var _got_nfe = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* nfe */
                _field.`type` match {
                  case TType.STRUCT => {
                    nfe = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_nfe = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_nfe) Some(nfe) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of UserVCommentResult.  You typically should not need to
     * directly reference this class; instead, use the UserVCommentResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val nfe: Option[NotFoundException] = None
    ) extends UserVCommentResult
  
  }
  
  trait UserVCommentResult extends ThriftStruct
    with Product1[Option[NotFoundException]]
    with java.io.Serializable
  {
    import UserVCommentResult._
  
    def nfe: Option[NotFoundException]
  
    def _1 = nfe
  
    override def write(_oprot: TProtocol) {
      UserVCommentResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (nfe.isDefined) {
        val nfe_item = nfe.get
        _oprot.writeFieldBegin(NfeField)
        nfe_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      nfe: Option[NotFoundException] = this.nfe
    ): UserVCommentResult = new Immutable(
      nfe
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[UserVCommentResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => nfe
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "UserVCommentResult"
  }
  
  class FinagledClient(
    val service: FinagleService[ThriftClientRequest, Array[Byte]],
    val protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
    val serviceName: String = "",
    stats: StatsReceiver = NullStatsReceiver
  ) extends FutureIface {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected def encodeRequest(name: String, args: ThriftStruct) = {
      val buf = new TMemoryBuffer(512)
      val oprot = protocolFactory.getProtocol(buf)
  
      oprot.writeMessageBegin(new TMessage(name, TMessageType.CALL, 0))
      args.write(oprot)
      oprot.writeMessageEnd()
  
      val bytes = Arrays.copyOfRange(buf.getArray, 0, buf.length)
      new ThriftClientRequest(bytes, false)
    }
  
    protected def decodeResponse[T <: ThriftStruct](resBytes: Array[Byte], codec: ThriftStructCodec[T]) = {
      val iprot = protocolFactory.getProtocol(new TMemoryInputTransport(resBytes))
      val msg = iprot.readMessageBegin()
      try {
        if (msg.`type` == TMessageType.EXCEPTION) {
          val exception = TApplicationException.read(iprot) match {
            case sourced: SourcedException =>
              if (serviceName != "") sourced.serviceName = serviceName
              sourced
            case e => e
          }
          throw exception
        } else {
          codec.decode(iprot)
        }
      } finally {
        iprot.readMessageEnd()
      }
    }
  
    protected def missingResult(name: String) = {
      new TApplicationException(
        TApplicationException.MISSING_RESULT,
        name + " failed: unknown result"
      )
    }
  
    // ----- end boilerplate.
  
    private[this] val scopedStats = if (serviceName != "") stats.scope(serviceName) else stats
    private[this] object __stats_ping {
      val RequestsCounter = scopedStats.scope("ping").counter("requests")
      val SuccessCounter = scopedStats.scope("ping").counter("success")
      val FailuresCounter = scopedStats.scope("ping").counter("failures")
      val FailuresScope = scopedStats.scope("ping").scope("failures")
    }
  
    /** Test for connectivity */
    def ping(): Future[String] = {
      __stats_ping.RequestsCounter.incr()
      this.service(encodeRequest("ping", PingArgs())) flatMap { response =>
        val result = decodeResponse(response, PingResult)
        val exception =
          (result.te).map(Future.exception)
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("ping")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_ping.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_ping.FailuresCounter.incr()
        __stats_ping.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_recPosts {
      val RequestsCounter = scopedStats.scope("recPosts").counter("requests")
      val SuccessCounter = scopedStats.scope("recPosts").counter("success")
      val FailuresCounter = scopedStats.scope("recPosts").counter("failures")
      val FailuresScope = scopedStats.scope("recPosts").scope("failures")
    }
  
    /** Request a list of posts that are most appropriate for a user
         * @param user_id, the user that the posts are being requested for
         */
    def recPosts(userId: Long): Future[PostList] = {
      __stats_recPosts.RequestsCounter.incr()
      this.service(encodeRequest("recPosts", RecPostsArgs(userId))) flatMap { response =>
        val result = decodeResponse(response, RecPostsResult)
        val exception =
          (result.nfe orElse result.ee orElse result.te).map(Future.exception)
        exception.orElse(result.success.map(Future.value)).getOrElse(Future.exception(missingResult("recPosts")))
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_recPosts.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_recPosts.FailuresCounter.incr()
        __stats_recPosts.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_userVPost {
      val RequestsCounter = scopedStats.scope("userVPost").counter("requests")
      val SuccessCounter = scopedStats.scope("userVPost").counter("success")
      val FailuresCounter = scopedStats.scope("userVPost").counter("failures")
      val FailuresScope = scopedStats.scope("userVPost").scope("failures")
    }
  
    /** Alert the recommender that a user has actioned a post
         * @param user_id, the user that performed the action
         * @param verb, the action taken (this is from the Action enum)
         * @param post_id, the post that the action is being performed on
         */
    def userVPost(userId: Long, verb: Action, postId: Long): Future[Unit] = {
      __stats_userVPost.RequestsCounter.incr()
      this.service(encodeRequest("userVPost", UserVPostArgs(userId, verb, postId))) flatMap { response =>
        val result = decodeResponse(response, UserVPostResult)
        val exception =
          (result.nfe).map(Future.exception)
        Future.Done
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_userVPost.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_userVPost.FailuresCounter.incr()
        __stats_userVPost.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
    private[this] object __stats_userVComment {
      val RequestsCounter = scopedStats.scope("userVComment").counter("requests")
      val SuccessCounter = scopedStats.scope("userVComment").counter("success")
      val FailuresCounter = scopedStats.scope("userVComment").counter("failures")
      val FailuresScope = scopedStats.scope("userVComment").scope("failures")
    }
  
    /** Alert the recommender that a user has actioned a comment
         * @param user_id, the user that performed the action
         * @param verb, the action taken (this is from the Action enum)
         * @param comment_id, the comment that the action is being performed on
         */
    def userVComment(userId: Long, verb: Action, commentId: Long): Future[Unit] = {
      __stats_userVComment.RequestsCounter.incr()
      this.service(encodeRequest("userVComment", UserVCommentArgs(userId, verb, commentId))) flatMap { response =>
        val result = decodeResponse(response, UserVCommentResult)
        val exception =
          (result.nfe).map(Future.exception)
        Future.Done
      } rescue {
        case ex: SourcedException => {
          if (this.serviceName != "") { ex.serviceName = this.serviceName }
          Future.exception(ex)
        }
      } onSuccess { _ =>
        __stats_userVComment.SuccessCounter.incr()
      } onFailure { ex =>
        __stats_userVComment.FailuresCounter.incr()
        __stats_userVComment.FailuresScope.counter(ex.getClass.getName).incr()
      }
    }
  }
  
  class FinagledService(
    iface: FutureIface,
    protocolFactory: TProtocolFactory
  ) extends FinagleService[Array[Byte], Array[Byte]] {
    // ----- boilerplate that should eventually be moved into finagle:
  
    protected val functionMap = new mutable.HashMap[String, (TProtocol, Int) => Future[Array[Byte]]]()
  
    protected def addFunction(name: String, f: (TProtocol, Int) => Future[Array[Byte]]) {
      functionMap(name) = f
    }
  
    protected def exception(name: String, seqid: Int, code: Int, message: String): Future[Array[Byte]] = {
      try {
        val x = new TApplicationException(code, message)
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.EXCEPTION, seqid))
        x.write(oprot)
        oprot.writeMessageEnd()
        oprot.getTransport().flush()
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    protected def reply(name: String, seqid: Int, result: ThriftStruct): Future[Array[Byte]] = {
      try {
        val memoryBuffer = new TMemoryBuffer(512)
        val oprot = protocolFactory.getProtocol(memoryBuffer)
  
        oprot.writeMessageBegin(new TMessage(name, TMessageType.REPLY, seqid))
        result.write(oprot)
        oprot.writeMessageEnd()
  
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    final def apply(request: Array[Byte]): Future[Array[Byte]] = {
      val inputTransport = new TMemoryInputTransport(request)
      val iprot = protocolFactory.getProtocol(inputTransport)
  
      try {
        val msg = iprot.readMessageBegin()
        functionMap.get(msg.name) map { _.apply(iprot, msg.seqid) } getOrElse {
          TProtocolUtil.skip(iprot, TType.STRUCT)
          exception(msg.name, msg.seqid, TApplicationException.UNKNOWN_METHOD,
            "Invalid method name: '" + msg.name + "'")
        }
      } catch {
        case e: Exception => Future.exception(e)
      }
    }
  
    // ---- end boilerplate.
  
    addFunction("ping", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = PingArgs.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.ping()
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: String =>
          reply("ping", seqid, PingResult(success = Some(value)))
        } rescue {
          case e: TimeoutException => {
            reply("ping", seqid, PingResult(te = Some(e)))
          }
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("ping", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("recPosts", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = RecPostsArgs.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.recPosts(args.userId)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: PostList =>
          reply("recPosts", seqid, RecPostsResult(success = Some(value)))
        } rescue {
          case e: NotFoundException => {
            reply("recPosts", seqid, RecPostsResult(nfe = Some(e)))
          }
          case e: EngineException => {
            reply("recPosts", seqid, RecPostsResult(ee = Some(e)))
          }
          case e: TimeoutException => {
            reply("recPosts", seqid, RecPostsResult(te = Some(e)))
          }
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("recPosts", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("userVPost", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = UserVPostArgs.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.userVPost(args.userId, args.verb, args.postId)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Unit =>
          reply("userVPost", seqid, UserVPostResult())
        } rescue {
          case e: NotFoundException => {
            reply("userVPost", seqid, UserVPostResult(nfe = Some(e)))
          }
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("userVPost", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
    addFunction("userVComment", { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = UserVCommentArgs.decode(iprot)
        iprot.readMessageEnd()
        (try {
          iface.userVComment(args.userId, args.verb, args.commentId)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: Unit =>
          reply("userVComment", seqid, UserVCommentResult())
        } rescue {
          case e: NotFoundException => {
            reply("userVComment", seqid, UserVCommentResult(nfe = Some(e)))
          }
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("userVComment", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    })
  }
}