/**
 * generated by Scrooge 3.0.5-SNAPSHOT
 */
package october

import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec}
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import scala.collection.mutable
import scala.collection.{Map, Set}


object Recommender {
  trait Iface {
    
    @throws(classOf[TimeoutException])
    def ping(): String
    
    @throws(classOf[NotFoundException])
    @throws(classOf[EngineException])
    @throws(classOf[TimeoutException])
    def recPosts(userId: Long): PostList
  }


  
  object PingArgs extends ThriftStructCodec[PingArgs] {
    val Struct = new TStruct("PingArgs")
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: PingArgs) {
    }
  
    def encode(_item: PingArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): PingArgs = decode(_iprot)
  
    def apply(
    ): PingArgs = new Immutable(
    )
  
    def unapply(_item: PingArgs): Boolean = true
  
    object Immutable extends ThriftStructCodec[PingArgs] {
      def encode(_item: PingArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
        )
      }
    }
  
    /**
     * The default read-only implementation of PingArgs.  You typically should not need to
     * directly reference this class; instead, use the PingArgs.apply method to construct
     * new instances.
     */
    class Immutable(
    ) extends PingArgs
  
  }
  
  trait PingArgs extends ThriftStruct
    with Product
    with java.io.Serializable
  {
    import PingArgs._
  
  
  
    override def write(_oprot: TProtocol) {
      PingArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
    ): PingArgs = new Immutable(
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[PingArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "PingArgs"
  }
  
  object PingResult extends ThriftStructCodec[PingResult] {
    val Struct = new TStruct("PingResult")
    val SuccessField = new TField("success", TType.STRING, 0)
    val TeField = new TField("te", TType.STRUCT, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: PingResult) {
    }
  
    def encode(_item: PingResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): PingResult = decode(_iprot)
  
    def apply(
      success: Option[String] = None,
      te: Option[TimeoutException] = None
    ): PingResult = new Immutable(
      success,
      te
    )
  
    def unapply(_item: PingResult): Option[Product2[Option[String], Option[TimeoutException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[PingResult] {
      def encode(_item: PingResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var success: String = null
        var _got_success = false
        var te: TimeoutException = null
        var _got_te = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRING => {
                    success = {
                      _iprot.readString()
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* te */
                _field.`type` match {
                  case TType.STRUCT => {
                    te = {
                      TimeoutException.decode(_iprot)
                    }
                    _got_te = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_te) Some(te) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of PingResult.  You typically should not need to
     * directly reference this class; instead, use the PingResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[String] = None,
      val te: Option[TimeoutException] = None
    ) extends PingResult
  
  }
  
  trait PingResult extends ThriftStruct
    with Product2[Option[String], Option[TimeoutException]]
    with java.io.Serializable
  {
    import PingResult._
  
    def success: Option[String]
    def te: Option[TimeoutException]
  
    def _1 = success
    def _2 = te
  
    override def write(_oprot: TProtocol) {
      PingResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        _oprot.writeString(success_item)
        _oprot.writeFieldEnd()
      }
      if (te.isDefined) {
        val te_item = te.get
        _oprot.writeFieldBegin(TeField)
        te_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[String] = this.success, 
      te: Option[TimeoutException] = this.te
    ): PingResult = new Immutable(
      success, 
      te
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[PingResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => te
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "PingResult"
  }
  
  object RecPostsArgs extends ThriftStructCodec[RecPostsArgs] {
    val Struct = new TStruct("RecPostsArgs")
    val UserIdField = new TField("userId", TType.I64, 1)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: RecPostsArgs) {
    }
  
    def encode(_item: RecPostsArgs, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): RecPostsArgs = decode(_iprot)
  
    def apply(
      userId: Long
    ): RecPostsArgs = new Immutable(
      userId
    )
  
    def unapply(_item: RecPostsArgs): Option[Long] = Some(_item.userId)
  
    object Immutable extends ThriftStructCodec[RecPostsArgs] {
      def encode(_item: RecPostsArgs, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var userId: Long = 0L
        var _got_userId = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* userId */
                _field.`type` match {
                  case TType.I64 => {
                    userId = {
                      _iprot.readI64()
                    }
                    _got_userId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        if (!_got_userId) throw new TProtocolException("Required field 'RecPostsArgs' was not found in serialized data for struct RecPostsArgs")
        new Immutable(
          userId
        )
      }
    }
  
    /**
     * The default read-only implementation of RecPostsArgs.  You typically should not need to
     * directly reference this class; instead, use the RecPostsArgs.apply method to construct
     * new instances.
     */
    class Immutable(
      val userId: Long
    ) extends RecPostsArgs
  
  }
  
  trait RecPostsArgs extends ThriftStruct
    with Product1[Long]
    with java.io.Serializable
  {
    import RecPostsArgs._
  
    def userId: Long
  
    def _1 = userId
  
    override def write(_oprot: TProtocol) {
      RecPostsArgs.validate(this)
      _oprot.writeStructBegin(Struct)
      if (true) {
        val userId_item = userId
        _oprot.writeFieldBegin(UserIdField)
        _oprot.writeI64(userId_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      userId: Long = this.userId
    ): RecPostsArgs = new Immutable(
      userId
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[RecPostsArgs]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => userId
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "RecPostsArgs"
  }
  
  object RecPostsResult extends ThriftStructCodec[RecPostsResult] {
    val Struct = new TStruct("RecPostsResult")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val NfeField = new TField("nfe", TType.STRUCT, 1)
    val EeField = new TField("ee", TType.STRUCT, 2)
    val TeField = new TField("te", TType.STRUCT, 3)
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: RecPostsResult) {
    }
  
    def encode(_item: RecPostsResult, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = Immutable.decode(_iprot)
  
    def apply(_iprot: TProtocol): RecPostsResult = decode(_iprot)
  
    def apply(
      success: Option[PostList] = None,
      nfe: Option[NotFoundException] = None,
      ee: Option[EngineException] = None,
      te: Option[TimeoutException] = None
    ): RecPostsResult = new Immutable(
      success,
      nfe,
      ee,
      te
    )
  
    def unapply(_item: RecPostsResult): Option[Product4[Option[PostList], Option[NotFoundException], Option[EngineException], Option[TimeoutException]]] = Some(_item)
  
    object Immutable extends ThriftStructCodec[RecPostsResult] {
      def encode(_item: RecPostsResult, _oproto: TProtocol) { _item.write(_oproto) }
      def decode(_iprot: TProtocol) = {
        var success: PostList = null
        var _got_success = false
        var nfe: NotFoundException = null
        var _got_nfe = false
        var ee: EngineException = null
        var _got_ee = false
        var te: TimeoutException = null
        var _got_te = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      PostList.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 1 => { /* nfe */
                _field.`type` match {
                  case TType.STRUCT => {
                    nfe = {
                      NotFoundException.decode(_iprot)
                    }
                    _got_nfe = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 2 => { /* ee */
                _field.`type` match {
                  case TType.STRUCT => {
                    ee = {
                      EngineException.decode(_iprot)
                    }
                    _got_ee = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case 3 => { /* te */
                _field.`type` match {
                  case TType.STRUCT => {
                    te = {
                      TimeoutException.decode(_iprot)
                    }
                    _got_te = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None,
          if (_got_nfe) Some(nfe) else None,
          if (_got_ee) Some(ee) else None,
          if (_got_te) Some(te) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of RecPostsResult.  You typically should not need to
     * directly reference this class; instead, use the RecPostsResult.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[PostList] = None,
      val nfe: Option[NotFoundException] = None,
      val ee: Option[EngineException] = None,
      val te: Option[TimeoutException] = None
    ) extends RecPostsResult
  
  }
  
  trait RecPostsResult extends ThriftStruct
    with Product4[Option[PostList], Option[NotFoundException], Option[EngineException], Option[TimeoutException]]
    with java.io.Serializable
  {
    import RecPostsResult._
  
    def success: Option[PostList]
    def nfe: Option[NotFoundException]
    def ee: Option[EngineException]
    def te: Option[TimeoutException]
  
    def _1 = success
    def _2 = nfe
    def _3 = ee
    def _4 = te
  
    override def write(_oprot: TProtocol) {
      RecPostsResult.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (nfe.isDefined) {
        val nfe_item = nfe.get
        _oprot.writeFieldBegin(NfeField)
        nfe_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (ee.isDefined) {
        val ee_item = ee.get
        _oprot.writeFieldBegin(EeField)
        ee_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      if (te.isDefined) {
        val te_item = te.get
        _oprot.writeFieldBegin(TeField)
        te_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[PostList] = this.success, 
      nfe: Option[NotFoundException] = this.nfe, 
      ee: Option[EngineException] = this.ee, 
      te: Option[TimeoutException] = this.te
    ): RecPostsResult = new Immutable(
      success, 
      nfe, 
      ee, 
      te
    )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[RecPostsResult]
  
    override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 4
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case 1 => nfe
      case 2 => ee
      case 3 => te
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "RecPostsResult"
  }
}